# lit 仕様書

## 目的
litはFUSE互換のユーザ空間ファイルシステムとして振る舞い、通常のディレクトリを透過的に監視・管理する。開発者は既存のツールチェーンを変更せずにlitをマウントしたディレクトリ上で作業を行い、全編集履歴を高精度で追跡・復元できる。

## コマンド体系
- すべてのCLIは`lit <subcommand>`形式で提供する。
- 主要サブコマンド例: `lit mount`, `lit unmount`, `lit status`, `lit log`, `lit checkout`, `lit sync`, `lit snapshot`, `lit blob fetch`。
- サブコマンドはFUSEサービスと通信し、必要に応じてgRPC/UNIXソケット経由でデーモンに指示を送る。

## システム要件
- **FUSE互換実装**: ユーザ空間で動作し、POSIXファイル操作(オープン/クローズ/リード/ライト/renameなど)やメタデータ操作(chmod/chown/utimens、ディレクトリ作成/削除、シンボリックリンク/ハードリンク、拡張属性)を余さずフックしてイベントを取得する。
- **マウントターゲット**: 任意の既存ディレクトリに`lit mount <path>`のような形でマウントし、アンマウント時もデータを失わない。
- **履歴記録**: 監視下ファイルに対するすべての編集操作をイベントログに記録。ログにはタイムスタンプ、操作種別、呼び出しコンテキスト(UID/PID)、対象パス、メタデータ差分を含め、任意の時点(ブロックIDやメタデータのロジカルクロック)に再生して状態復元できる。
- **データ分類**: 管理対象ファイルをテキスト(文字列CRDTで内容を追跡)とblob(バイナリ/大容量)に二分し、blobは内容差分を取らずバージョン単位で保管する。拡張子や MIME で自動判別し、手動オーバーライドも可能とする。
- **履歴記録**: 監視下ファイルに対するすべての編集操作をイベントログに記録。ログにはタイムスタンプ、操作種別、呼び出しコンテキスト(UID/PID)、対象パス、メタデータ差分を含め、任意の時点(ブロックIDやメタデータのロジカルクロック)に再生して状態復元できる。
- **CRDT同期**: 他ノードと状態を交換する際はCRDT(例: Logoot、RGAなど)を用いて、同一ファイルへ複数編集者が同時に操作しても競合を自動解決し、終状態が収束する。
- **ローカル/リモート複製**: 編集ログはローカルストレージに永続化され、一定間隔でチェックポイント(スナップショット)を作成。必要に応じてリモートピアへ複製・マージできる。

## コンポーネント構成
1. **Filesystem Adapter**: libfuse等を使いOSからのシステムコールを受け、lit内部イベントに変換。
2. **Operation Logger**: ファイル操作を正規化し、順序付きログとして保存。操作単位で内容差分またはデータブロックを格納。
3. **Snapshot Manager**: 一定間隔または操作数でワーキングツリー全体/ディレクトリ単位のスナップショットを生成し、履歴の圧縮と高速復元を実現。
4. **State Replayer**: 過去の任意ポイントへロールバック/ロールフォワードするためのリプレイ機構。CRDTのロジカル時計とログシーケンス、スナップショットを併用して復元時間を短縮。
5. **CRDT Engine**: 編集操作をCRDT要素にエンコードし、ファイル内容(テキスト)、ファイルツリー構造(rename/move)、メタデータをそれぞれ型付きCRDT(例:文字列にはRGA/Logoot、ツリーにはWOOT/HTree)で管理。他ピアから受け取った操作をコミューテーション可能な形でマージ。
6. **Networking Layer (任意)**: ピア探索とイベント配布を担当。存在しない場合はローカル単体利用が可能。

## 主要フロー
### マウント
1. `lit mount /path/to/workdir` を実行。
2. Filesystem AdapterがFUSE経由でマウントポイントを作成。
3. 対象ディレクトリ構造を初期スナップショットとして取り込み、操作ログの起点(ロジカルクロック0)を作る。

### 編集追跡
1. ユーザがファイルを編集すると、システムコールがAdapterに渡る。
2. Operation Loggerが差分を記録し、テキストとblobを分類。テキストはCRDT Engineが位置ベースCRDTに変換し、blobは変更単位のオブジェクトを丸ごと新バージョンとして保存する。ディレクトリ操作はツリーCRDT、メタデータはLast-Writer-Winsレジスタを利用。
3. ローカルログに追記し、必要ならネットワーク層へブロードキャスト。マウント外で直接書き換えが発生した場合は inotify 等で検知し、FUSEロールバックまたは警告を行う。

## 編集単位とログ構造
1. **低レベルイベント(システムコール単位)**: `read/write/truncate/rename`などFUSEから受け取るすべてのイベントを即時記録。各イベントにはPID/UID/FD/タイムスタンプを付与し、障害復旧の最小データとして扱う。
2. **内部操作バッチ**: 同一PID+FDで閾値時間(例:50ms)以内に発生した低レベルイベントをまとめ、1つの「内部操作」に昇格させる。大量writeをバッチングし、CRDTやblobバージョン更新のトリガーとする。
3. **ユーザー向け編集ブロック**: テキストはCRDT操作(挿入/削除)を論理位置単位でまとめ、`lit log`で閲覧できる人間可読な差分として提示。blobは書き込み完了後に自動的に1バージョンとして固め、バージョンIDで参照できる。必要に応じて`lit commit`等のサブコマンドで明示的にタグ付け・コメント付けができる。
4. **区切りトリガー**: ファイルクローズ、一定アイドル時間経過、`lit save`など明示コマンドの実行で内部操作を確定させる。これにより「無意識の編集」も確実に履歴へ残しつつ、履歴の細分化を防ぐ。

### 時点復元
1. 利用者が`lit checkout --timestamp <t>`や`--op-id <id>`で復元ポイントを指定。
2. State Replayerが直近のスナップショットから指定ポイントまでログを再生するか、逆方向に差分を適用して状態を再構築。ロールバック時は未コミット操作を一時退避して再適用する仕組みを提供。

### マージ/同期
1. ピア間でログ(またはCRDT操作)を交換。
2. CRDT Engineがコミュタティブ性を利用して操作を統合。バージョンベクタやロジカルクロックで既適用操作を判定。
3. 結果状態を再生してローカルツリーへ反映。同じ操作は冪等的に扱われる。

## CRDT設計要件
- **テキストファイル**: 文字列用CRDT(RGA/Logoot)を採用し、改行単位と文字単位の双方を選択できる。大きなファイルではチャンク化して挿入/削除コストを抑える。
- **ファイルツリー**: ディレクトリとrename/moveはトポロジー保持型CRDT(TreeDocなど)で表現し、同名衝突は決定的な命名規則(例:タイムスタンプ付与)で解決。
- **メタデータ**: chmod/chown/タイムスタンプ等はLWWレジスタまたはMin/Maxレジスタで管理し、CRDTが未対応のフィールドはログ順で決定する。
- **バイナリ/巨大ファイル(blob)**: デフォルトでは不可分のblobとして扱い、内容は差分ではなくバージョン単位で保存・取得する。CRDTはメタデータのみ同期し、内容は最新バージョンまたはユーザ指定バージョンを選択。必要ならプラグイン的にカスタムCRDTを差し込める拡張ポイントを提供。

## チェックポイントとガーベジコレクション
- スナップショット生成ポリシー(時間間隔または操作件数閾値)を設定可能にし、復元時間を O(log n) 程度に抑える。
- 古いログは全ピア反映済みであることを確認した上でガーベジコレクションし、必要部分のみ保持。
- チェックポイントはメタデータと内容を分離保存し、部分リストア(特定ディレクトリ/ファイルのみ)にも対応する。

## 非機能要件
- **堅牢性**: 不意のクラッシュ後でもログから復旧できるよう、操作記録はジャーナリングする。
- **性能**: 小さな操作単位でログ化するとI/O負荷が大きいため、バッチングや差分圧縮を行う。高頻度I/Oディレクトリはパススルーモードやライトバックキャッシュを選べるようにし、FUSE起因のレイテンシを抑える。
- **セキュリティ**: ログには機微情報を含むため、暗号化やアクセス制御を検討。
- **監査性**: すべての操作にUID/PID/ホストIDを紐付け、追跡可能にする。

## 今後の課題
- CRDTアルゴリズム選定とバイナリファイル編集への適用方法
- 巨大リポジトリでのログ管理(ガーベジコレクションやチェックポイント)
- ネットワークプロトコル仕様(認証、暗号化、遅延耐性)
